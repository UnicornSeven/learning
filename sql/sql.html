<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="stylesheet" href="styles/style.css">
  <title>SQL</title>
</head>
<body>
  <div class="header"></div>
  <div class="mainbody">
    <div class="container">
      <h2>SQL必知必会</h2>
      <div class="content">
        <div class="section">
          <h3>阅读目标</h3>
          <ol>
            <li>快速学会并熟练使用SQL</li>
            <li>如何使用SQL开发应用程序</li>
            <li>在无人帮助的情况下有效而快速地使用SQL</li>
          </ol>
        </div>
      </div>
      <div class="content">
        <div class="section">
          <h3>数据库管理系统（DBMS</h3>
          <ol>
            <li>Apache Open Office Base</li>
            <li>IBM DB2</li>
            <li>Microsoft Access</li>
            <li>Microsoft SQL Server</li>
            <li>MariaDB</li>
            <li>MySQL</li>
            <li>Oracle</li>
            <li>PostgreSQL</li>
            <li>SQLite</li>
          </ol>
        </div>
      </div>
      <div class="content">
         <h3>了解SQL</h3>
         <div class="section">
           <h4>数据库基础</h4>
           <ul>
             <li>什么是SQL</li>
             <li>SQL有什么用</li>
             <li>基本的数据库术语</li>
           </ul>
         </div>
         <div class="section">
           <h4>基本的数据库术语</h4>
           <ol>
               <li>数据库是一个以某种有组织的方式存储的数据集合</li>
               <li>数据库「database」保存有组织的数据的容器</li>
               <li>DBMS数据库管理系统：数据库软件应称为数据库管理系统。数据库是通过DBMS创建和操纵的容器，而具体它究竟是什么，形式如何，各种数据库都不一样。</li>
               <li>表是一种结构化的文件，可用来存储某种特定类型的数据</li>
               <li>表「table」某种特定类型数据的结构化清单。关键点在于，存储在表中的数据是同一种类型的数据或清单。数据库中表的名字是唯一的，在不同的数据库中完全可以使用相同的表名。</li>
               <li>模式「schema」关于数据库和表的布局及特性的信息。表具有一些特性，用来定义数据在表中如何存储、存储什么样的数据、数据如何分解，各部分信息如何命名等信息。模式可以用来描述数据库中特定的表，也可以用来描述整个数据库。</li>
               <li>列「column」表中的一个字段。所有表都是由一个或多个列组成的。</li>
               <li>数据类型「datatype」所允许的数据的类型。每个列表都有相应的数据类型，它限制该列中存储的数据。数据类型还帮助正确地分类数据，并在优化磁盘使用方面起重要作用。</li>
               <li>行「row」表中的一个记录「record」</li>
               <li>主键「primary key」一列（或一组列），其值能够唯一标识表中的每一行。表中的任何列都可以作为主键，只要它满足以下条件：任意两行都不具有相同的主键值；每一行都必须具有一个主键值（主键列不允许NULL值）；主键列中的值不允许修改或更新；主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）</li>
           </ol>
         </div>
         <div class="section">
           <h4>什么是SQL</h4>
           <ol>
             <li>SQL是一种专门用来与数据库沟通的语言，是Structured Query Language（结构化查询语言）的缩写。设计SQL的目的是为了提供一种从数据库中读写数据的简单有效的方法。</li>
             <li>SQL的优点：几乎所有DBMS都支持SQL；SQL简单易学；SQL灵活易用，可进行非常复杂和高级的数据库操作。</li>
           </ol>
         </div>
      </div>
      <div class="content">
        <div class="section">
          <h3>检索数据</h3>
          <ul>
            <li>如何使用SQL的SELECT语句来检索单个列表、多个列表以及所有列表</li>
            <li>如何返回不同的值</li>
            <li>如何注释代码</li>
          </ul>
        </div>
        <div class="section">
          <h4>SELECT语句</h4>
          <ol>
            <li>关键词「keyword」作为SQL组成部分的保留字。关键字不能用作表或列的名字。</li>
            <li>每个SQL语句都是由一个或多个关键字构成的</li>
            <li>检索单个列：必须给出两个条件，想选择什么以及从哪选择。例如，利用SELECT语句从Products表中检索一个名为prod_name的列。返回的是表中所有行，未过滤也未排序的数据。</li>
            <li>多条SQL语句必须以分号分隔</li>
            <li>SQL语句不区分大小写</li>
            <li>在处理SQL语句时，所有空格都被忽略</li>
            <li>检索多个列：列名之间必须以逗号分隔</li>
            <li>检索所有列：使用星号通配符；列的顺序一般是列在表定义中出现的物理顺序（数据返回给应用程序，根据需要进行格式化，再表示出来）</li>
            <li>检索不同的值：使用「DISTINCT」关键字，它指示数据库只返回不同的值；DISTINCT关键字作用于所有的列</li>
            <li>限制结果：在MySQL数据库中使用「LIMIT」关键字来限制返回行数；<code>LIMIT 5 OFFSET 2</code> 指示MySQL等DBMS返回从第2行起的5行数据。第一个数字是检索的行数，第二个数字是指从哪里开始检索</li>
            <li>第0行：第一个被检索的行是第0行，而不是第1行。因此，LIMIT 1 OFFSET 1检索的是第2行，而不是第1行。</li>
            <li>使用注释：SQL语句是由DBMS处理的指令。添加注释使用两个连字符（——）嵌在行内或者使用/*之间都是注释*/</li>
          </ol>
        </div>
      </div>
      <div class="content">
        <div class="section">
          <h3>排序检索数据</h3>
          <ul>
            <li>如何使用SQL的SELECT语句的ORDER BY子句对检索出的数据进行排序</li>
            <li>ORDER BY子句必须是SELECT语句中的最后一条子句</li>
            <li>如何对一个或多个列进行升序／降序排序</li>
          </ul>
        </div>
        <div class="section">
          <h3>排序数据</h3>
          <ol>
            <li>子句「clause」：SQL语句由子句构成，有些子句是必需的，有些则是可选的。一个子句通常由一个关键字加上所提供的数据组成。</li>
            <li>ORDER BY子句：取一个或多个子句，据此对SELECT语句检索出的数据进行排序</li>
            <li>ORDER BY子句的位置：确保是SELECT语句中最后一条子句，不然会出现错误信息</li>
            <li>ORDER BY子句可对非选择列进行排序</li>
            <li>按多个列排序：简单指定列名，列名之间用逗号分开</li>
            <li>按列位置排序：支持按SELECT清单中指定的选择列的相对位置排序，容易出错</li>
            <li>指定排序方向：升序ASC「ASCENDING」／降序DESC「DESCENDING」</li>
            <li>在多个列上降序排序：关键字DESC只对指定列有效，想在多个列上降序排序，必须对每一列指定DESC关键字</li>
          </ol>
        </div>
      </div>
      <div class="content">
        <div class="section">
          <h3>过滤数据</h3>
          <ul>
            <li>如何使用SQL的SELECT语句的WHERE子句过滤返回的数据</li>
            <li>如何检验相等、不相等、大于、小于、值的范围以及NULL值</li>
          </ul>
        </div>
        <div class="section">
          <h4>使用WHERE子句</h4>
          <ol>
            <li>过滤条件「filter condition」：根据报告的需要指定搜索条件「search criteria」检索数据</li>
            <li>SQL过滤与应用过滤：使用客户端过滤数据，需要服务器通过网络发送多余的数据，会造成网络带宽的浪费。优化数据库后可以快速有效地对数据进行过滤</li>
            <li> WHERE子句的位置：ORDER BY子句应位于最后一句</li>
            <li>WHERE子句操作符：等于（=）／不等于（!=）／小于（<）／小于等于（<=）／不小于（!<）／大于（>）／大于等于（>=）／不大于（!>）／在指定的两个值之间「BETWEEN」／为NULL值「IS NULL」</li>
            <li>检索单个值 <code>WHERE prod_price <= 10;</code></li>
            <li>不匹配检查 <code>WHERE vend_id != ‘DLL01’; </code></li>
            <li>何时使用引号：值跟字符串类型的列进行比较，就需要限定引号；用来与数值列进行比较的值不用引号</li>
            <li>范围值检查：要检查某个范围的值，可以使用BETWEEN操作符，需要指定范围的开始值和结束值，这两个值必须使用AND关键字分隔。BETWEEN匹配范围中所有的值，包括指定的开始值和结束值。 <code>WHERE prod_price BETWEEN 5 AND 10;</code></li>
            <li>空值检查：表设计人员在指定其中的列不包含值时，可以称其包含空值NULL 。NULL无值「no value」与字段包含0、空字符串或仅仅包含空格不同。</li>
            <li>检索NULL值：SELECT 语句中有一个特殊的WHERE子句IS NULL，可以用来检索空值。<code>WHERE prod_price  IS NULL;</code></li>
            <li>NULL和非匹配：在进行匹配过滤或非匹配过滤时，不会返回含NULL值的行；过滤数据时，一定要验证被过滤列中含NULL的行确实出现在返回的数据中</li>
          </ol>
        </div>
      </div>
      <div class="content">
        <div class="section">
          <h3>高级数据过滤</h3>
          <ul>
            <li>如何使用AND和OR操作符组合成WHERE子句</li>
            <li>如何明确管理求值顺序</li>
            <li>如何使用IN和NOT操作符</li>
          </ul>
        </div>
        <div class="section">
          <h4>组合WHERE子句</h4>
          <ol>
            <li>操作符「operator」：用来联结或改变WHERE子句中的子句的关键字，也称为逻辑操作符「logical operator」AND/OR</li>
            <li>AND操作符：通过AND操作符可以使用多个条件进行过滤 </li>
            <li>AND：用在WHERE子句中的关键字，用来指示检索满足所有给定条件的行
              <code>WHERE vend_id = ‘DLL01’ AND prod_price <= 4;</code></li>
            <li>OR：指示DBMS检索匹配任一条件的行</li>
            <li>求值顺序：WHERE子句可以包含任意数目的AND和OR操作符；允许两者结合以进行复杂、高级的过滤。AND在求值过程中优先级更高，需要使用圆括号对操作符进行明确分组。</li>
            <li>圆括号：求值顺序更高；任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括号明确地分组操作符
              <code>WHERE ( vend_id = ‘DLL01’ OR vend_id = ‘BRS01’ ) AND prod_price >= 10;</code></li>
            <li>IN操作符：IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配。IN取一组由逗号分隔、括在圆括号中的合法值
              <code>WHERE vend_id IN (‘DLL01’,’BRS01’);</code></li>
            <li>IN：WHERE子句中用来指定要匹配值的清单的关键字，功能与OR相当，语法更清楚直观，求值顺序更容易管理，执行更快，能更动态建立WHERE子句</li>
            <li>NOT操作符：否定其后跟的任何条件。用在要匹配的列前
              <code>WHERE NOT vend_id = ‘DLL01’;</code></li>
          </ol>
        </div>
      </div>
      <div class="content">
        <div class="section">
          <h3>用通配符进行过滤</h3>
          <ul>
            <li>什么是通配符</li>
            <li>如何使用通配符</li>
            <li>怎样使用LIKE操作符进行通配搜索</li>
          </ul>
        </div>
        <div class="section">
          <h4>LIKE操作符</h4>
          <ol>
            <li>通配符（wildcard）：用来匹配值的一部分的操作符</li>
            <li>搜索模式（search pattern）：由字面值、通配符或两者组合构成的搜索条件</li>
            <li>利用通配符，可以创建比较特定数据的搜索模式；通配符本身实际上是SQL的WHERE子句中有特殊含义的字符。在搜索子句中使用通配符，必须使用LIKE操作符</li>
            <li>谓词（predicate），从技术上说LIKE是谓语，而不是操作符</li>
            <li>通配符搜索只能用于文本字段（字符串），非文本数据类型字段不能使用通配符搜索</li>
          </ol>
        </div>
        <div class="section">
          <h4>百分号（%）通配符</h4>
          <ol>
            <li>在搜索中，%表示任何字符出现任意次数
              <code>WHERE prod_name LIKE ‘Fish%’;</code>此例子使用搜索模式’Fish%’，在执行这条子句时，将检索任意以Fish起头的值</li>
            <li>区分大小写：根据DBMS的不同及其配置，搜索可以是区分大小写的</li>
            <li>通配符可以在搜索模式的任意位置使用，并且可以使用多个通配符 <code>WHERE prod_name LIKE ‘%bean bag%’;</code>%代表搜索模式中给定位置的0个、1个或多个字符</li>
            <li>注意NULL <code>WHERE prod_name LIKE ‘%’;</code>不会匹配产品名称为NULL的行</li>
          </ol>
        </div>
        <div class="section">
          <h4>下划线（_）通配符</h4>
          <ol>
            <li>匹配单个字符 <code>WHERE prod_name LIKE ‘_ inch teddy bear’;</code></li>
            <li>使用%通配符 <code>WHERE prod_name LIKE ‘% inch teddy bear’;</code>能匹配多个字符，而_只能匹配一个字符</li>
          </ol>
        </div>
        <div class="section">
          <h4>方括号（[ ]）通配符</h4>
          <ol>
            <li>方括号（[ ]）通配符用来指定一个字符集，它必须匹配指定位置的一个字符。例如，找出所有名字以J或M起头的联系人<code>WHERE cust_contact LIKE ‘[JM]%’;</code></li>
            <li>匹配方括号中任意一个字符，只能匹配单个字符；%匹配第一个字符之后的任意数目的字符</li>
            <li>脱字符：使用前缀字符脱字符来否定  。例如，’[^JM]%’不以字母J或M起头的联系人</li>
          </ol>
        </div>
        <div class="section">
          <h4>使用通配符的技巧</h4>
          <ol>
            <li>通配符搜索比其他搜索要耗费更长的处理时间</li>
            <li>不要过度使用通配符</li>
            <li>不要把通配符置于开始处，搜索最慢</li>
            <li>仔细注意通配符的位置</li>
          </ol>
        </div>
      </div>
      <div class="content">
        <div class="section">
          <h3>创建计算字段</h3>
          <ul>
            <li>什么是计算字段</li>
            <li>如何创建计算字段</li>
            <li>如何从应用程序中使用别名引用计算字段</li>
          </ul>
        </div>
        <div class="section">
          <h4>计算字段</h4>
          <ol>
            <li>存储在数据表中的数据一般不是应用程序所需要的格式，需要直接从数据库中检索出转换、计算或格式化过的数据</li>
            <li>计算字段是运行时在SELECT语句内创建的</li>
            <li>字段「field」：基本上与列「column」意思相同，术语字段通常与计算字段一起使用</li>
            <li>注意：只有数据库知道SELECT语句中哪些列是实际的表列，哪些列是计算字段</li>
            <li>客户端与服务器的格式：在服务器上完成数据的格式转换比在客户端上完成这些操作要快得多</li>
          </ol>
        </div>
        <div class="section">
          <h4>拼接字段</h4>
          <ol>
            <li>拼接「concatenate」将值连接到一起构成单个值<code>SELECT vend_name + vend_country; ／SELECT Concat(vend_name, vend_country);</code></li>
            <li>TRIM( )/RTRIM( )/LTRIM( )函数：去空格</li>
            <li>使用别名：别名「alias」是一个字段或值的替换名，用AS关键字赋予别名有时候也称为导出列「derived column」</li>
            <li><code>SELECT RTRIM(vend_name) + RTRIM(vend_country) AS vend_title;</code> AS vend_title指示SQL语句创建一个包含指定计算结果的名为vend_title的计算字段，任何客户端都可以按名称引用这个列</li>
          </ol>
        </div>
        <div class="section">
          <h4>执行算术计算</h4>
          <ol>
            <li>计算字段：对检索出的数据进行算术计算<code>SELECT prod_id, quantity, item_price, quantity*item_price AS expanded_price;</code></li>
            <li>SQL算术操作符：加（+）减（-）乘（*）除（／）</li>
            <li>如何测试计算：SELECT通常用于检索数据，但省略FROM子句后就是简单地访问和处理表达式</li>
            <li>可以根据需要使用SELECT语句进行检测：<code>SELECT Now( );</code></li>
          </ol>
        </div>
      </div>
      <div class="content">
        <div class="section">
          <h3>使用函数处理数据</h3>
          <ul>
            <li>什么是函数</li>
            <li>DBMS支持何种函数</li>
            <li>如何使用这些函数</li>
            <li>为什么SQL函数的使用会带来问题</li>
          </ul>
        </div>
        <div class="section">
          <h4>函数</h4>
          <ol>
            <li>函数一般在数据上执行的，为数据的转换和处理提供方便</li>
            <li>每一个DBMS都有特定的函数；虽然所有类型的函数一般都可以在每个DBMS中使用，但各个函数的名称和语法可能极其不同</li>
            <li>DBMS函数的差异：例如，提取字符串的组成部分；数据类型的转换；取当前日期等函数在不同DBMS函数不同</li>
            <li>可移植（portable）：所编写的代码可以在多个系统上运行</li>
            <li>与SQL语句不一样，SQL函数是不可移植的</li>
          </ol>
        </div>
        <div class="section">
          <h4>使用函数</h4>
          <ol>
            <li>用于处理文本字符串（如删除或填充值，转换值为大写或小写）的文本函数；</li>
            <li>用于数值数据上进行算术操作（如返回绝对值，进行代数运算）的数值函数；</li>
            <li>用于处理日期和时间值并从这些值中提取特定成分（如返回两个日期之差，检查日期有效性）的日期和时间函数；</li>
            <li>返回正使用的特殊信息（如返回用户登录信息）的系统函数</li>
          </ol>
        </div>
        <div class="section">
          <h4>文本处理函数</h4>
          <ol>
            <li>返回字符串的长度（LENGTH( )）</li>
            <li>将字符串转换为大写字母（UPPER( )）</li>
            <li>将字符串转换为小写字母（LOWER( )）</li>
            <li>返回字符串左边的函数（LEFT( )）</li>
            <li>去掉字符串左边的空格（LTRIM( )）</li>
            <li>返回字符串的SOUNDEX值（SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法）</li>
          </ol>
        </div>
        <div class="section">
          <h4>日期和时间处理函数</h4>
          <ol>
            <li>日期和时间采用相应的数据类型存储在表中，每种DBMS都有自己的特殊形式</li>
            <li>应用程序一般不使用日期和时间的存储格式，因此日期和时间函数总是用来读取、统计和处理这些值。</li>
          </ol>
        </div>
        <div class="section">
          <h4>数值处理函数</h4>
          <p>数值处理函数仅处理数值数据，这些函数一般主要用于代数、三角或几何运算。在主要的DBMS的函数中，数值函数是最一致、最统一的函数</p>
          <ol>
            <li>返回一个数的绝对值（ABS( )）</li>
            <li>返回一个角度的余弦（COS( )）</li>
            <li>返回一个角度的正弦（SIN( )）</li>
            <li>返回一个角度的正切（TAN( )）</li>
            <li>返回一个数的平方根（SQRT( )）</li>
            <li>返回一个数的指数值（EXP( )）</li>
          </ol>
        </div>
      </div>
      <div class="content">
        <div class="section">
          <h3>汇总数据</h3>
          <ul>
            <li>什么是SQL的聚集函数</li>
            <li>如何使用它们汇总表的数据</li>
          </ul>
        </div>
        <div class="section">
          <h4>聚集函数</h4>
          <ol>
            <li>SQL查询可用于检索数据，利用聚集函数汇总数据，以便分析和报表生成</li>
            <li>需要汇总数据，而不需要实际数据本身的例子：找出表列（或所有行或某些特定的行）的最大值、最小值、平均值</li>
            <li>聚集函数（aggregate function）：对某些行运行的函数，计算并返回一个值</li>
          </ol>
        </div>
        <div class="section">
          <h4>SQL聚集函数</h4>
          <ol>
            <li>返回某列的平均值（AVG( )）</li>
            <li>返回某列的行数（COUNT( )）</li>
            <li>返回某列的最大值（MAX( )）</li>
            <li>返回某列的最小值（MIN( )）</li>
            <li>返回某列值之和（SUM( )）</li>
            <li>AVG( )函数：通过对表中行数计数并计算其列值之和，求得该列的平均值。AVG( )函数可用来返回所有列的平均值，也可以用来返回特定列或行的平均值</br>
            <code>SELECT AVG(prod_price) AS avg_price;</code></li>
            <li>只能用于单个列：AVG( )只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出</li>
            <li>NULL值：AVG( )函数忽略值为NULL的行</li>
            <li>COUNT( )函数：确定表中行的数目或符合特定条件的行的数目</li>
            <li>使用方式：使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值还是非空值；使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值</li>
            <li>只对具有电子邮件地址的客户计数</br><code>SELECT COUNT(cust_email) AS num_cust;</code></li>
            <li>MAX( )函数返回指定列中的最大值，要求指定列名，忽略NULL值</li>
            <li>MIN( )函数返回指定列的最小值，要求指定列名，忽略NULL值</li>
            <li>SUM( )函数用来返回指定列值的和，也可以用来合计计算值</br><code>SELECT SUM(item_price*quantity) AS total_price;</code></li>
            <li>聚集不同值：对所有行执行计算，指定ALL参数或不指定参数（ALL是默认行为）；只包含不同的值，指定DISTINCT参数</br><code>SELECT AVG(DISTINCT prod_price) AS avg_price;</code></li>
            <li>组合聚集函数：SELECT语句可根据需要包含多个聚集函数</li>
            <li>取别名：在指定别名包含某个聚集函数的结果时，不应该使用表中的实际列名</li>
          </ol>
        </div>
      </div>
      <div class="content">
        <div class="section">
          <h3>分组数据</h3>
          <ul>
            <li>如何分组数据，以便汇总表内容的子集</li>
            <li>GROUP BY子句</li>
            <li>HAVING子句</li>
          </ul>
        </div>
        <div class="section">
          <h4>聚集函数</h4>
          <ol>
            <li>使用分组可以将数据分为多个逻辑组，对每个组进行聚集计算</li>
            <li>创建分组：GROUP BY子句指示DBMS分组数据，对每个组而不是整个结果集进行聚集</li>
            <li>统计每个供应商提供的产品数量：按供应商的ID对数据进行排序分组，利用COUNT(*)进行统计。会对每个vend_id而不是整个表进行计算num_prods</br>
            <code>SELECT vend_id, COUNT(*) AS num_prods  FROM Products GROUP BY vend_id;</code></li>
            <li>GROUP BY子句必须出现在WHERE子句之后，ORDER BY 子句之前</li>
            <li>如果分组列中包含有NULL值的行，将分为一组；</li>
            <li>除聚集计算语句外，SELECT语句中的每一列都必须在GROUP BY子句中给出</li>
            <li>大多数SQL实现不允许GROUP BY列带有长度可变的数据类型（如文本或备注型字段）；</li>
            <li>GROUP BY子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数），如果在SELECT中使用表达式，则必须在子句中指定相同的表达式，不能使用别名；</li>
            <li>如果在GROUP BY子句中嵌套了分组，数据将在最后指定的分组上进行汇总，在建立分组时，指定的列一起计算，不能从个别的列取回数据；</li>
            <li>GROUP BY子句可以包含任意数目的列，因而可以对分组进行嵌套，更细致地进行数据分组。</li>
          </ol>
        </div>
        <div class="section">
          <h4>过滤分组</h4>
          <ol>
            <li>除了GROUP BY分组数据之外，SQL还支持过滤分组，规定包括哪些分组，排除哪些分组</li>
            <li>HAVING子句过滤分组：HAVING过滤分组，WHERE过滤指定的行而不是分组</li>
            <li>HAVING和WHERE的差别： WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤</li>
            <li>列出具有两个以上产品且其价格大于等于4的供应商</br>
              <code>SELECT vend_id, COUNT(*) AS num_prods
                    FROM Products
                    WHERE prod_price >= 4
                    GROUP BY vend_id
                    HAVING COUNT(*) > 2;</code></li>
            <li>使用HAVING和WHERE：使用HAVING时应该结合GROUP BY子句，而WHERE子句用于标准的行级过滤</li>
          </ol>
        </div>
        <div class="section">
          <h4>分组和排序</h4>
          <ol>
            <li>ORDER BY和GROUP BY的差别：</li>
            <li>ORDER BY子句对产生的输出进行排序，任意列都可以使用（甚至非选择的列也可以使用），不一定需要聚集函数；</li>
            <li>GROUP BY子句对行分组，但输出可能不是分组的顺序，只可能使用选择列或表达式列，而且必须使用每个选择列表达式，如果与聚集函数一起使用列（或表达式），则必须使用</li>
            <li>一般在使用GROUP BY子句时，应该也给出ORDER BY子句，不要依赖GROUP BY排序数据</li>
            <li>检索包含三个或更多物品的订单号和订购物品的数目：使用GROUP BY子句按订单号分组数据，以便COUNT(*)函数能够返回每个订单中的物品数量；HAVING子句过滤数据，使得只返回包含三个或更多物品的订单；最后用ORDER BY子句排序输出
            </br><code>
                  SELECT order_num, COUNT(*) AS items
                  FROM OrderItems
                  GROUP BY order_num
                  HAVING COUNT(*) >= 3;
                  ORDER BY items, order_num;
                </code></li>
          </ol>
        </div>
        <div class="section">
          <h4>SELECT子句顺序</h4>
          <ol>
            <li>SELECT：要返回的列或表达式，必须使用</li>
            <li>FROM：从中检索数据的表，仅在从表中选择数据时使用</li>
            <li>WHERE：行级过滤，不是必须使用</li>
            <li>GROUP BY：分组说明，仅在按组计算聚集时使用</li>
            <li>HAVING：组级过滤，不是必须使用</li>
            <li>ORDER BY：输出排序顺序，不是必须使用</li>
          </ol>
        </div>
        <div class="section">
          <h4>小结</h4>
          <ol>
            <li>如何使用GROUP BY子句对多组数据进行汇总计算，返回每个组的结果</li>
            <li>如何使用HAVING子句过滤特定的组</li>
            <li>ORDER BY与GROUP BY之间的差异</li>
            <li>WHERE与HAVING之间的差异</li>
          </ol>
        </div>
      </div>
      <div class="content">
        <div class="section">
          <h3>使用子查询</h3>
          <ul>
            <li>什么是子查询</li>
            <li>如何使用子查询</li>
          </ul>
        </div>
        <div class="section">
          <h4>子查询</h4>
          <ol>
            <li>查询（query）:任何SQL语句都是查询，但此术语一般指SELECT语句，从单个数据表中检索数据的单条语句</li>
            <li>子查询（subquery）：嵌套在其他查询中的查询</li>
          </ol>
        </div>
        <div class="section">
          <h4>利用子查询进行过滤</h4>
          <ol>
            <li>列出订购物品RGAN01的所有顾客：检索包含物品RGAN01的所有订单的编号</br>
              <code>SELECT order_num FROM OrderItems WHERE prod_id = ‘RGAN01’；</code></br>
                检索具有前一步骤列出的所有的订单编号的所有顾客的ID</br>
              <code>SELECT cust_id FROM Customers WHERE order_num IN (20007,20008)；</code>
                检索前一步骤返回的所有顾客ID的顾客信息</br>
              <code>SELECT cust_name, cust_contact FROM Customers WHERE cust_id IN (‘1000004’,’1000005’);</code></li>
            <li>在WHERE子句中使用子查询能够编写出功能很强且很灵活的SQL语句。对于能嵌套的子查询的数目没有限制，不过在实际使用中由于性能的限制，不能嵌套太多的子查询。</li>
            <li>作为子查询的SELECT语句只能查询单个列，企图检索多个列将返回错误</li>
          </ol>
        </div>
        <div class="section">
          <h4>作为计算字段使用子查询</h4>
          <ol>
            <li>显示Customers表中每个顾客的订单总数。执行这个操作，需要遵循下面的步骤：</br>
                从Customers表中检索顾客列表；</br>
                对于检索出的每个顾客，统计其在Orders表中的订单数目</br>
              <code>SELECT cust_name, cust_state, (SELECT COUNT(*) FROM Orders WHERE Customers.cust_id = Orders.cust_id) AS order_nums
                    FROM Customers
                    ORDER BY cust_name;</code></li>
            <li>完全限定列名：指定表名和列名，语法上用一个句点分隔表名和列名</li>
            <li>如果在SELECT语句中操作多个表，就应使用完全限定列名来避免歧义，没有具体指定会返回错误结果</li>
          </ol>
        </div>
      </div>
      <div class="content">
        <div class="section">
          <h3>联结表</h3>
          <ul>
            <li>什么是联结</li>
            <li>为什么使用联结</li>
            <li>如何编写使用联结的SELECT语句</li>
          </ul>
        </div>
        <div class="section">
          <ol>
            <li>联结</br>SQL最强大的功能之一就是能在数据查询的执行中联结（join）表，联结是利用SQL的SELECT能执行的最重要的操作</li>
            <li>关系表</br>关系表的设计就是要把信息分解成多个表，一类数据一个表，各表通过某些共同的值互相关联（所以才叫关系数据库</li>
            <li>可伸缩（scale）：能够适应不断增加的工作量而不失败，设计良好的数据库或应用程序称为可伸缩性好</li>
            <li>为什么使用联结</br>将数据分解为多个表能更有效地存储，更方便地处理，并且可伸缩性更好</br>
                将数据存储在多个表中，通过联结检索出数据。简单说，联结是一种机制，用来在一条SELECT语句中关联表，因此称为联结</br>
                使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行</br>
            </li>
            <li>创建联结</br>创建联结：指定要联结的所有表以及要关联它们的方式</br>
                <code>SELECT vend_name, prod_name, prod_price
                      FROM Vendors, Products
                      WHERE Vendors.vend_id = Products.vend_id;</code></li>
            <li>SELECT语句指定要关联的表的名字，WHERE子句指示DBMS将Vendors表中的vend_id与Products表中的vend_id匹配起来</li>
            <li>WHERE子句的重要性：</br>
                在一条SELECT语句中联结几个表时，相应的关系是在运行中构造的，在数据库表的定义中没有指示DBMS如何对表进行联结。
            </li>
            <li>在联结两个表时，实际要做的是将第一个表中的每一行与第二个表中的每一行配对；WHERE子句作为过滤条件，只包含那些匹配给定条件（联结条件）的行</li>
            <li>笛卡尔积（cartesian product）：由没有联结条件的表关系返回的结果为笛卡尔积，也称为叉联结（cross join）。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数</li>
            <li>要保证所有联结都有WHERE子句，同时保证WHERE子句的正确性</li>
            <li>内联结</br>
                等值联结／内联结（inner join）：基于两个表之间的相等测试，可以对这种联结使用不同的语法，明确指定联结的类型</br>
              <code>SELECT vend_name, prod_name, prod_price FROM Vendors INNER JOIN Products ON Vendors.vend_id = Products.vend_id;</code>
            </li>
            <li>联结条件用特定的ON子句而不是WHERE子句给出，传递给ON的实际条件与传递给WHERE的相同</li>
            <li>联结多个表</br>SQL不限制一条SELECT语句中可以联结的表的数目，创建联结的基本规则也相同。首先列出所有表，然后定义表之间的关系</li>
            <li>显示订单20007中的物品 :</br><code>SELECT prod_name, vend_name, prod_price, quantity FROM Vendors, OrderItems, Products WHERE Vendors.vend_id = Products.vend_id AND OrderItems.prod_id = Products.prod_id AND order_num = 20007;</code></li>
            <li>DBMS在运行时关联指定的每个表，以处理联结，这种处理非常耗费资源。联结的表越多，性能下降越厉害</li>
            <li>执行任一给定的SQL操作一般不止一种方法，很少有绝对正确或绝对错误的方法。性能可能会受操作类型、所使用的DBMS、表中的数据量、是否存在索引或键等条件的影响</li>
          </ol>
        </div>
      </div>
      <div class="content">
        <div class="section">
          <h3>创建高级联结</h3>
          <ul>
            <li>如何以及为什么使用别名</li>
            <li>不同的联结类型以及每类联结所使用的语法</li>
            <li>如何与联结一起使用聚集函数</li>
            <li>使用联结时应该注意的问题</li>
          </ul>
        </div>
        <div class="section">
          <h4>使用表别名</h4>
          <ol>
            <li>SQL除了可以对列名和计算字段使用别名，还允许给表名起别名：可以缩短SQL语句；允许在一条SELECT语句中多次使用相同的表</br>
              <code>SELECT cust_name, cust_contact FROM Customers AS C, Orders AS O, OrderItems AS OI WHERE C.cust_id = O.cust_id AND O.oder_num = OI.order_num AND prod_id = 'RGAN01';</code>
            </li>
            <li>表别名只在查询执行中使用，与列表名不一样，表别名不返回到客户端</li>
          </ol>
        </div>
        <div class="section">
          <h4>使用不同类型的联结</h4>
          <ol>
            <li>自联结（self-join）：使用表别名的一个重要的原因是能在一条SELECT语句中不止一次引用相同的表；自联结通常作为外部语句，用来替代从相同表中检索数据的子查询语句</li>
            <li>要给与Jim Jones同一公司的所有顾客发送一封信件：找出Jim Jones工作的公司，然后找出该公司工作的顾客。</br>
              <code>SELECT c1.cust_id, c1.cust_name, c1.cust_contact FROM Customers AS c1, Customers AS c2 WHERE c1.cust_name = c2.cust_name AND  c2.cust_contact = 'Jim Jones';</code>
            </li>
            <li>SELECT语句使用明确给出所需列的全名，指示DBMS哪一列（其实它们是同一列）；WHERE子句联结两个表，然后按第二个表中cust_contact的过滤数据，返回所需的数据</li>
            <li>自然联结（natural join）：标准的联结返回所有数据，相同的列甚至多次出现；自然联结排除多次出现，使每一列只返回一次</li>
            <li>自然联结要求你只能选择那些唯一的列，一般通过对一个表使用通配符（SELECT *），而对其他表的列使用明确的子集来完成</li>
            <li>很少有不是自然联结的内联结，基本上每个内联结都是自然联结</li>
            <li>外联结（outer join）：许多联结将一个表中的行与另一个表中的行相关联，但有时候需要包含没有关联行的那些行，这种联结称为外联结</li>
            <li>使用内联结，检索所有顾客及其订单；使用外联结，检索包括没有顾客在内的所有顾客</li>
            <li>选择FROM子句左边的表（Customers表）中选择所有行</li>
            <li>在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是 OUTER JOIN右边的表，而 LEFT 指出的是OUTER JOIN左边的表）</li>
            <li>外联结的类型：左外联结和右外联结之间唯一的差别是所关联的表的顺序。调整FROM或WHERE子句中表的顺序，左外联结可以转换成右外联结</li>
            <li>全外联结（full outer join）：检索两个表中的所有行并关联那些可以关联的行，全外联结包含两个表的不关联的行</li>
          </ol>
        </div>
        <div class="section">
          <h4>使用带聚集函数的联结</h4>
          <ol>
            <li>例子：要检索所有顾客及每个顾客所下的订单数</br>
              <code>SELECT Customers.cust_id, COUNT(Orders.order_num) AS num_orders FROM   Customers INNER JOIN Orders ON  Customers.cust_id = Orders.cust_id GROUP BY Customers.cust_id;</code>
            </li>
            <li>这条SELECT语句使用INNER JOIN将Customers和Orders表互相关联；GROUP BY子句按顾客分组数据，因此函数调用COUNT(Orders.order_num)对每个顾客的订单计数，将它作为num_ord返回</li>
          </ol>
        </div>
        <div class="section">
          <h4>使用联结和外联结条件</h4>
          <ol>
            <li>注意所使用的联结类型</li>
            <li>关于确切的联结语法，应该查看具体文档，看相应的DBMS支持何种语法</li>
            <li>保证使用正确的联结条件，否则会返回不正确的数据</li>
            <li>总是提供联结条件，否则会得出笛卡尔积</li>
            <li>在一个联结中可以包含多个表，甚至可以对每个联结采用不同的联结类型</li>
          </ol>
        </div>
      </div>
      <div class="content">
        <div class="section">
          <h3>组合查询</h3>
          <ul>
            <li>如何利用UNION操作符将多条SELECT语句结合组合成一个结果集</li>
          </ul>
        </div>
        <div class="section">
          <h3>组合查询</h3>
          <ol>
            <li>组合查询（union）或复合查询（compound query）：多数SQL语句只包含一个或多个从表中返回数据的单条SELECT语句；SQL也允许执行多个查询，并将结果作为一个查询结果集返回</li>
            <li>什么时候使用组合查询：</br>在一个查询中从不同的表返回数据结构；</br>对一个表执行多个查询，按一个查询返回数据</li>
            <li>组合条件和多个WHERE查询：任何具有多个WHERE子句的SELECT语句都可以作为一个组合查询</br><code>SELECT cust_name, cust_contact, cust_email FROM   Customers WHERE  cust_state IN ('IL','IN','MI') OR  cust_name = 'Fun4A11';</code></li>
            <li>创建组合查询例子</br>
              <code>SELECT cust_name,cust_contact,cust_email
                    FROM  Customers
                    WHERE cust_state IN ('IL','IN','MI');</br>
                    UNION</br>
                    SELECT cust_name, cust_contact, cust_email
                    FROM   Customers
                    WHERE  cust_name = 'Fun4A11';</code></li>
            <li>使用UNION ：</br>
                使用UNION很简单，给出每条SELECT语句，在各条语句之间放上关键词UNION</br>
                UNION指示DBMS执行这两条SELECT语句，并把输出组合成一个查询结果集。</br>
                使用UNION组合SELECT语句的数目，SQL没有标准限值，最好参考一下具体的DBMS文档
            </li>
            <li>UNION规则</br>
                UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔</br>
                UNION中的每个查询必须包含相同的列、表达式或聚集函数（各个列不需要以相同的次序列出）</br>
                列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含转换的类型</br>
            </li>
            <li>包含或取消重复的行</br>
                UNION从查询结果集中自动去除重复的行</br>
                UNION ALL：使用UNION ALL返回所有的匹配行，DBMS不取消重复的行</br>
              <code>SELECT cust_name,cust_contact,cust_email
                    FROM  Customers
                    WHERE cust_state IN ('IL','IN','MI');</br>
                    UNION ALL</br>
                    SELECT cust_name, cust_contact, cust_email
                    FROM   Customers
                    WHERE  cust_name = 'Fun4A11';</code>
            </li>
            <li>对组合查询结果排序</br>
                使用UNION组合查询时，只能使用一条ORDER BY子句，它必须位于最后一条SELECT语句之后；对于结果集，不存在用一种方式排序一部分，而用另一种方式排序另一种部分的情况</br>
                <code>SELECT cust_name,cust_contact,cust_email
                      FROM  Customers
                      WHERE cust_state IN ('IL','IN','MI');</br>
                      UNION</br>
                      SELECT cust_name, cust_contact, cust_email
                      FROM   Customers
                      WHERE  cust_name = 'Fun4A11'
                      ORDER BY cust_name, cust_contact;</code>
            </li>
          </ol>
        </div>
      </div>
    </div>
  </div>
  <div class="footer"></div>
</body>
</html>
