<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="stylesheet" href="../styles/css-style.css">
  <title>CSS</title>
</head>
<body>
  <div class="header">
    <h2>CSS权威指南</h2>
  </div>
  <div class="mainbody">
    <div class="container">
      <div class="content">
        <h3>HTML与CSS</h3>
        <div class="section">
          <ol>
            <li>HTML是一种结构化标记语言，用于描述文档的不同部分</li>
            <li>CSS样式表：将所有样式规则放到一张表中，易于修改</li>
            <li>在多页上引用样式表：可以快速创建风格一致的网站；需要修改网页风格的时候只要对一个样式表进行修改</li>
            <li>层叠：对冲突规则做了约定；由于层叠的特性，规则可以覆盖</li>
            <li>XML可扩展标记语言「Extensible Markup Language」</li>
            <li>元素「element」</br>
                是文档结构的基础，每个元素生成一个盒子「box」其中包含元素的内容</br>
                替换元素「replaced element」：是指用来替换元素内容的部分并非由文档内容直接表示，例如：img元素、input元素等</br>
                非替换元素「nonreplaced element」：大多数HTML与XTHML都是非替换元素，其内容由用户代理（通常是浏览器）在元素本身生成的框中显示</br>
                块级元素「block-level」：块级元素生成一个元素框，默认会填充其父元素的内容区，旁边不能有其他元素，即默认分行，例如：div元素、p元素</br>
                行内元素「inline-level」：行内元素在文本行内生成元素框，而不会打断这行文本，例如：span元素、a元素、em元素</br>
            </li>
            <li>link标记：链接样式表和文档</br>
                外部样式表「external style sheet」：HTML的外部样式表；为了成功加载样式表，link标签必须放在head元素中</br>
                属性：rel「relation」表示关系，关系为stylesheet；type属性的值为text/css，描述了使用link标记加载的数据的类型，确定浏览器如何处理其导入的数据；href属性，属性的值是样式表的URL，可以是绝对URL，也可以是相对URL</br>
                候选样式表「alternate style sheet」将rel属性的值设置为alternate stylesheet可以定义候选样式表，只有用户选择这个样式表时才会用于文档表现
            </li>
            <li>style元素</br>
                可以用style元素包含样式表：style一定要使用type属性；</br>
                文档样式表（document style sheet）或嵌套样式表（embedded style sheet）：可以包含多个应用到文档的样式表，可以使用<code>@import</code>指令包含多个外部样式表链接</br>
                @import指令：<code>@import url(sheet2.css);</code>用于指示浏览器加载一个外部样式表；指令的位置必须出现在style容器中，指令出现在样式表的开头；一个文档中可以不只有一个@import语句，且每个@import指令的样式表都会加载并使用</br>
                用途：可以用于需要用到其他外部样式表中的样式表<code>@import url(print.css); body{color:red;}</code>
            </li>
            <li>CSS注释：单行注释、多行注释</li>
            <li>内联样式（inline style）：</br>利用HTML的style属性为单个元素指定一些样式</br>
                style属性的语法：把大括号换成双引号，与style容器中的声明相似；一个内联style属性中只能放一个声明块，而不能放整个样式表
            </li>
          </ol>
        </div>
      </div>
      <div class="content">
        <div class="section">
          <h3>CSS选择器</h3>
          <ul>
            <li>掌握CSS以何种方式选择文档中要应用样式的部分</li>
            <li>CSS的主要功能就是将某些规则应用于文档中同一类型的元素</li>
            <li>规则的结构：每条规则「rule」有两个部分，选择器「selector」和声明块「declaration block」声明块有一个或多个声明「declaration」组成，每条声明是属性和值的组合</br>
              <code>h1:{color:red;}  选择器：声明（属性：值）</code></br>
              规则的左边：选择器，定义了将影响文档中的哪些部分；</br>
              规则的右边：声明块，由一个或多个声明组成，每个声明是一个CSS属性和该属性值的结合
            </li>
            <li>声明和关键字：声明的格式，一个属性后面跟一个冒号，再后面是一个值，然后是一个分号；值要么是一个关键字，要么是该属性可取关键字的一个列表（包含一个或多个关键字），关键字之间用空格分隔</li>
          </ul>
        </div>
        <div class="section">
          <ol>
            <li>类选择器（class selector）：</br>允许以一种独立于文档元素的方式来指定样式。要应用样式而不考虑具体涉及的元素，可以用类选择器，修改具体的文档标记。为了将一个类选择器与元素关联，必须将class属性指定为一个适当的值</br>
              <code>p.warning {font-weight: bold;}</code> 选择器会匹配class属性包含值warning的所有p元素。每个规则只应用于某种特定类型的元素/类组合，不会影响其他元素。</br>
              <code>.warning {font-weight:bold;}  span.warning {color: red;}</code> 结合使用通用选择器和特定选择器设置样式。可以忽略星号，选择类名相同的所有元素</br>
                多类选择器：通过把两个类选择器链接在一起，仅可以选择同时包含这些类名的元素（类名的顺序不限）</br>
              <code>p.warning.urgent{ background:red; }</code>
            </li>
            <li>ID选择器（ID selector）：</br>ID选择器用#棋盘号而不是点号；ID选择器引用id属性中的值；id选择器也可以忽略星号通配符</br>
              <code>#first { font-weight:bold; }</code></br>
                类选择器和ID选择器区分大小写，取决于文档语言。</br>
                类选择器和文档选择器的区别：在一个HTML文档中，ID选择器只使用一次，一个ID值标记一个元素；不同于类选择器，ID选择器不能结合使用，因为ID属性不允许有以空格分隔的词列表；id名比class名能包含更多含义</br>
                相似性：类似于类，可以独立于元素来选择ID
            </li>
            <li>通配符选择器（universal selector）：</br><code>* {color:red;}</code>这个声明等价于列出了文档中所有元素的一个分组选择器；</br>
                除了可以对选择器分组，也可以对声明分组。对声明分组时，一定要在各个声明的最后使用分号。浏览器会忽略样式表中的空白符，而且用户代理必须依赖正确的语法才能解析样式表</li>
            <li>元素选择器：</br>文档中的某个元素，是最基本的选择器</li>
            <li>分组选择器：</br>为多个元素应用同一个样式，元素之间用逗号分隔 <code>h1,h2,h3,p{color:gray;}</code></li>
            <li>属性选择器(attribute selector)：</br>
                根据元素的属性及属性值来选择元素</br>
                简单属性选择：选择有某个属性的元素，而不论该属性的值是什么 <code>h1[class] { color:silver; }</code> 可以将多个属性选择器链接在一起，对多个属性进行选择</br>
                根据具体属性值选择：选择有特定属性值的元素，这种格式要求必须与属性值完全匹配<code>p[class="urgent warning"] { font-weight: bold; }</code>注意ID选择器与指定id属性的属性选择器有微妙但重要的差别</br>
                根据部分属性值选择：可以根据其中的任意一个词进行选择。<code>p[class~="warning"] {font-weight:bold;}</code>波浪号（~）根据属性值中出现的一个用空格分隔的词来完成选择
                特定属性选择类型：<code>[lang |= 'en'] {color:white;}</code>这个规则会选择lang属性等于en或以en-开头的所有元素
            </li>
            <li>伪类选择器：</br>
                锚元素：在HTML和XHTML中，锚元素会建立从一个文档到另一个文档的链接。要区别哪些链接是已访问的，需要将文档中的链接与用户的浏览历史相比较。
                基本的锚类型：已访问和未访问，这些类型称为伪类（pseudo-class），使用这些伪类的选择器称为伪类选择器（pseudo-class selector）。CSS定义了伪类，使已访问页面的锚自带visited伪类，注意规则中的冒号（:）<code>a:visited {color:red;}</code></br>
                链接伪类：伪类名 :link 指示作为超链接并指向一个未访问地址的所有锚<code>a:link{color:navy;}</code>；:visited 指示作为已访问地址超链接的所有锚<code>a:visited{color:gray;}</code>；类选择器如何与伪类结合，在带特定类的锚元素上使用伪类，语法也适用于ID选择器</br>
                动态伪类：伪类名 :focus指示当前拥有输入焦点的元素，可以接受键盘输入或者能以某种方式激活的元素<code>a:focus{color:red;}</code>；:hover指示鼠标指针停留在哪个元素上<code>a:hover{color:yellow;}</code>；:active指示被用户输入激活的元素<code>a:active{color:blue;}</code></br>
                选择第一个子元素：选择元素的第一个子元素:first-child 常常遭到误解 <code>p:first-child {font-weight: bold;}</code> 这个规则将作为某元素第一个子元素的所有p元素设置为粗体
                根据语言选择：使用伪类:lang( )来根据元素的语言来选择<code>:lang(fr) {font-style:italic;}</code></br>
                结合伪类：在同一个选择器中结合使用伪类，顺序不重要，但是不能把互拆的伪类结合在一起使用 <code>a:link:hover {color:red;}</code>
            </li>
            <li>伪元素选择器：</br>
                设置首字母样式：用于设置一个块级元素首字母的样式 <code>p:first-letter {color:red;}</code></br>
                设置第一行样式：用于设置元素中的第一个文本行 <code>p:first-line {color:purple;}</code> :first-line和:first-letter都有所限制，只能应用于标记段落之类的块级元素不能用于行内元素；同时对能应用的属性也有所限制。所有伪元素都必须放在出现该伪元素的选择器的最后面</br>
                设置之前样式：在伪元素前插入生成的内容，然后使用伪元素:before直接设置样式 <code>h2::before {content: "{}"; color:silver;}</code></br>
                设置之后样式：在伪元素之后插入生成的内容，并设置样式 <code>body::after {content: "The End.";}</code></br>
            </li>
            <li>使用文档结构：</br>
                理解父子关系：HTML文档以元素的一种层次结构为基础，元素之间存在父子关系。文档中的每个元素要么是另一个元素的父元素，要么是另一个元素的子元素，而且通常兼而有之。可以从文档的树视图了解这种层次结构</br>
                后代选择器（descendant selector/contextual selector）：</br><code>h1 em {color: gray;}</code> 规则左边的后代选择器中包含两个或多个用空格分隔的选择器，选择器之间的空格是一种结合符（combinator）后代选择器的两个元素之间的层次间隔可以是无限的。</br>
                选择子元素：不想选择后代元素，只想选择另一个元素的子元素<code>h1 > strong{color:red;}</code> 选择作为h1元素子元素的所有strong元素。查看文档的树结构，子选择器限制为只匹配树中直接相连的元素</br>
                选择相邻兄弟元素（adjacentsibling combinator）：选择紧接在另一个元素后的元素，而且二者具有相同的父元素，可以使用相邻兄弟结合符。<code>h1+p {margin:0;}</code>这个选择器读作“选择紧接在一个h1元素后出现的所有段落，h1要与所有p元素有共同的父元素”用一个结合符只能选择两个相邻兄弟中的第二个元素
            </li>
          </ol>
          <div class="image">
            <img src="../images/css/css-selector-1.png" alt="css-selector-1">
            <img src="../images/css/css-selector-2.png" alt="css-selector-2">
            <img src="../images/css/css-selector-3.png" alt="css-selector-3">
            <img src="../images/css/css-selector-4.png" alt="css-selector-4">
          </div>
        </div>
      </div>
      <div class="content">
        <h3>结构和层叠</h3>
        <div class="section">
          <ol>
            <li>上一章介绍了如何利用文档结构和CSS选择器为元素应用各种丰富的样式。每个合法的文档都会生成一个结构树，是继承机制的核心。</li>
            <li>继承（inheritance）是从一个元素向其后代元素传递属性值所采用的机制。</li>
            <li>层叠（cascade）确定对一个元素应用哪些值时，用户代理不仅需要考虑继承，还要考虑声明的特殊性以及声明本身的来源，这个过程就称为层叠（cascade）</li>
            <li>特殊性：同一个元素可以使用两个或多个规则来选择，每个规则都有自己的选择器。对于每个规则，用户代理会计算选择器的特殊性（specificity）并将这个特殊性附加到规则的各个声明</li>
            <li>如何确定一个选择器具体的特殊性：</br>
                ID属性值：0,1,0,0</br>
                类属性值、属性选择或伪类：0,0,1,0</br>
                元素和伪元素：0,0,0,1</br>
                结合符和通配符选择器对特殊性没有任何贡献：0,0,0,0</br>
            </li>
            <li>任何情况下，用户代理都会确定哪些规则与一个元素匹配，计算出所有相关的声明及其特殊性并将合适的样式应用到元素上</li>
            <li>通配选择器特殊性：有特殊性，为0,0,0,0；结合符没有特殊性</li>
            <li>ID和属性选择器的特殊性：前者为 0,1,0,0，后者为0,0,1,0</li>
            <li>内联样式特殊性：每个内联声明的特殊性都是1,0,0,0</li>
            <li>重要性（!important）：位置必须放在分号前面，否则重要声明将无效；没有特殊值，但会与非重要声明分开处理</li>
            <li>继承：基于继承机制，样式不仅应用到指定元素，还会应用到它的后代元素。元素不会把值向上传播，除了一个例外，应用到body元素的背景样式可以传递到html元素（html是文档的根元素）</li>
            <li>继承完全没有特殊性，需要向相关元素直接指定样式。例如，需要为用户代理的超链接指定样式</br><code>#toobar {color:white; background: black;} </br> #toolback a:link{color:white;}</code></li>
            <li>层叠：浏览器如何处理特殊性相等的两个规则同时应用到同一个元素</br>
                按权重和来源排序：如果两个样式规则应用到同一个元素，而且其中有一个规则有!important标志，这个重要规则将胜出 </br>
                按声明权重等级：读者的重要声明>创作人员的重要声明>创作人员的正常声明>读者的正常声明>用户代理声明</br>
                按特殊性排序：如果向一个元素应用多个彼此冲突的声明，而且它们的权重相同，则要按特殊性排序，最特殊的声明最优先</br>
                按顺序排序：如果两个规则的权重、来源和特殊性完全相同，那么在样式表中后出现的一个会胜出。通常推荐的链接样式顺序：LVHA
            </li>
            <li>非CSS表现提示：文档有可能包含非CSS的表现提示，例如font元素</li>
            <li>层叠：层叠的核心是选择器及其相关声明的特殊性，以及继承机制</li>
          </ol>
        </div>
      </div>
      <div class="content">
        <h3>值和单位</h3>
        <div class="section">
          <ol>
            <li>单位（unit）影响所有属性的颜色、距离和大小的一种元素</li>
            <li>数字：整数和实数</li>
            <li>百分数：百分数值是一个计算得出的实数，是一个相对值</li>
            <li>颜色：不同的命名法</br>
                用RGB指定颜色：函数式RGB颜色；十六进制RGB颜色</br>
                WEB安全颜色
            </li>
            <li>长度单位：</br>
                绝对长度单位：英寸（inch）、厘米（cm）、毫米（mm）、点（pt）、派卡（pc）</br>
                相对长度单位：em定义为给定字体的font-size的值；ex是指所用字体中小写x的高度；px像素：屏幕上的一个点
            </li>
            <li>URL <code>url(protocol://server/pathname)</code>绝对URL；<code>url(pathname)</code>相对URL</li>
            <li>关键字：有时一个值需要用某个词来描述，这种词就称为关键字；如果一个属性接受关键字，那么其关键字只针对该属性的作用域定义；inherit关键字是所有属性共有的</li>
            <li>单位：</br>
                角度值：用于定义给定声音从哪个位置发出
                时间值：用于指定语音元素之间的延迟
                频率值：用于语音浏览器可以产生的声音声明一个给定频率
            </li>
          </ol>
        </div>
      </div>
      <div class="content">
        <h3>字体</h3>
        <div class="section">
          <ol>
            <li>设置字体属性是样式表最常见的用途之一</li>
            <li>字体系列：相同的字体有不同的称呼，字体可能由许多字体变形组成，分别用来描述粗体、斜体文本等等。例如，Times是变形字体的一个组合，是一个字体系列（font-family），每种变形都是一个具体的字体风格（font-face）</li>
            <li>使用通用字体系列：可以使用属性font-family在文档中采用上述任何字体系列<code>body {font-family:sans-serif;}</code></br>指定字体系列：<code>h1 {font-family:Georgia;}</code>如果用户代理上该字体不能使用，则可能会使用默认字体代替</br>通过结合特定字体和通用字体系列：<code>h1 {font-family: Georgia, serif;}</code></br>使用引号：只有当一个字体名中有一个或多个空格，或字体名包含符号，才需要在font-family声明中加引号</li>
            <li>字体加粗：属性font-family；值normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | inherit</li>
            <li>字体大小：属性font-size；值xx-small | x-small | small | medium | large | x-large | xx-large | smaller | larger | <length> | <percentage> | inherit</br>绝对大小：7个绝对大小值；</br>相对大小：关键字larger和smaller；</br>百分数和大小：百分数值根据从父元素继承的大小来计算；字体大小和继承：字体大小是可以继承的，继承的是计算值而不是百分数</li>
            <li>使用长度单位：以下所有font-size声明都是等价的</br>
              <code>p.one {font-size:36pt;}</br>p.two {font-size: 3pc;}</br>p.three {font-size: 0.5in;}</br> p.four {font-size: 1.27cm;} </br> p.five {font-size: 12.7mm;}</code>
            </li>
            <li>风格和变形：属性font-style；值 italic | oblique | normal | inherit</br>字体变形：属性font-variant；值 small-caps | normal | inherit</li>
            <li>font属性：<code>h1 {font-family: Verdana, Helvetica, Arial, sans-serif; font-size: 30px; font-weight: 900; font-style: italic; font-variant: small-caps; line-height: 32px;}</code></li>
            <li>使用系统字体：captain用于有标题的控件、如按钮；icon用于对图标加标签；menu用于菜单，即下拉菜单和菜单列表；message-box用于对话框；small-caption用于对小控件加标签；status-bar用于窗口状态条</li>
            <li>字体匹配：CSS允许匹配字体系列、加粗和变形</li>
            <li>font-face规则：字体名匹配：智能字体匹配；字体合成；字体下载；</li>
          </ol>
        </div>
      </div>
      <div class="content">
        <h3>文本属性</h3>
        <div class="section">
          <ol>
            <li>文本和字体之间的区别：文本是内容，而字体用于显示这个内容。使用文本属性，可以控制文本相对于该行余下内容的位置、使其作为上标、加下划线，以及改变大小写等。</li>
            <li>缩进和水平对齐：</br>
                缩进文本：将Web页面上一个段落的第一行缩进，这是一种最常用的文本格式化效果。属性text-indent，值 length | percentage | inherit </br>
                一般地，可以为所有块级元素应用text-indent，但无法将这个属性应用到行内元素 <code> p {text-indent: 4em; }</code> </br>
            </li>
            <li>水平对齐：影响一个元素文本行相互之间的对齐方式；属性 text-align；值 left | center | right | justify | string | inherit </br></li>
            <li>垂直对齐：line-height属性是指文本行基线之间的距离，而不是字体的大小，它确定了将各个元素框的高度增加或减少多少。line-height值和字体大小之差就是行间距。</li>
            <li>属性：line-height；值 <code>length | percentage | number | normal | inherit</code></li>
            <li>构造文本行：文本行中的每个元素都会生成一个内容区，这由字体的大小确定。这个内容区则会生成一个行内框（inline box），如果不存在其他因素，这个行内框就完全等于该元素的内容区。</li>
            <li>要确定一个给定元素的行间距，只需将line-height的计算值减去font-size的计算值</li>
            <li>行高和继承：当一个块级元素从另一个元素继承line-height时，要从父元素计算，而不是在子元素上计算。指定一个数时，缩放因子将是继承值而不是计算值。<code>div {line-height: 1.5;} </br> p {font-size: 18px;}</code></li>
            <li>垂直对齐文本：只应用于行内元素和替换元素。属性：vertical-align；值 baseline | sub | super | top | text-top | middle | bottom | text-bottom | percentage | length | inherit</li>
            <li>基线对齐：vertical-align: baseline要求一个元素的基线与其父元素的基线对齐</li>
            <li>上标和下标： vertical-align: sub会使一个元素变成下标，这意味着其基线相对于其父元素的基线降低；super刚好与sub相反，它将元素的基线相对于父元素的基线升高。</li>
            <li>底端对齐：vertical-align:bottom将元素行内框的底端与行框的底端对齐。</br> vertical-align: text-bottom是指行内文本的底端</br> 顶端对齐：vertical-align: top效果与bottom刚好相反；
                vertical-align: text-top效果则与text-bottom效果相反</br>
                居中对齐：middle，往往应用于图像，会把行内元素框的中点与父元素基线上方0.5ex处的一个点对齐</br>
                百分数：为vertical-ailgn设置一个百分数，会把元素的基线相对于父元素的基线升高或降低指定的量（计算该元素line-height的百分数，而不是相对于其父元素的line-height）。</br>
                长度对齐：<code>vertical-align: 5px;</code> 所有垂直对齐的元素都会影响行高。
            </li>
            <li>字间隔和字母间隔：</br>
                字间隔： word-spacing 属性接受一个正长度值或负长度值。属性：word-spacing；值 length | normal | inherit </br>
                字母间隔： letter-spacing修改字符或字母之间的间隔。属性：letter-spacing; 值：length | normal | inherit </br>
                间隔和对齐：word-spacing的值可能受text-align属性值的影响
            </li>
            <li>文本转换：属性 text-transform；值 uppercase | lowercase | capitalize | none | inherit</li>
            <li>文本装饰：属性 text-decoration；值 none | underline | overline | line-through | blink | inherit</li>
            <li>文本阴影：属性 text-shadow； 值 none | [ color || length || length || length ] 每个阴影都由一个颜色和三个长度值来定义，前两个长度值确定了阴影与文本的偏移距离，第三个长度值可选
              <code>text-shadow: green 5px 0.5em;</code> 定义了一个相对于文本向右偏移5像素向下偏移0.5em的绿色阴影
            </li>
            <li>处理空白符：属性 white-space；值 normal | nowrap | pre | pre-wrap | pre-line | inherit 使用这个属性，可以影响浏览器处理字之间和文本行之间的空白符的样式</li>
            <li>文本方向：属性 direction； 值 ltr | rtl | inherit 属性影响块级元素中文本的书写方向、表中列布局的方向、内容水平填充其元素框的方向，以及两端对齐元素中最后一行的位置。</li>
          </ol>
        </div>
      </div>
      <div class="content">
        <h3>基本视觉格式化</h3>
        <div class="section">
          <h4>基本框</h4>
          <ol>
            <li>基本框：</br>
                元素框：CSS假定每个元素都会生成一个或多个矩形框。各元素框中心有一个内容区，内容区周围有可选的内边距、边框和外边距
            </li>
            <li>包含块：每个元素都相对于其包含块摆放</li>
            <li>重要术语复习：</br>
                正常流：从左向右、从上向下</br>
                非替换元素：元素的内容包含在文档中，则称之为非替换元素</br>
                替换元素：指作为其他内容占位符的一个元素，例如img元素，它指向一个图像文件</br>
                块级元素：指段落、标题或div之类的元素，会在其框之前和之后生成“换行”。通过声明display: block可以让元素生成块级框</br>
                行内元素：指strong或span之类的元素，不会生成“行分隔符”。通过声明dispaly: inline，可以让元素生成一个行内框</br>
                根元素：位于文档树顶端的元素
            </li>
          </ol>
        </div>
        <div class="section">
          <h4>块级元素</h4>
          <ol>
            <li>块级元素：一般地，一个元素的width被定义为从左内边界到右内边界的距离，height则是从上内边界到下内边界的距离。</li>
            <li>水平格式化：正常流中块级元素框的水平部分总和就等于父元素的width</li>
            <li>水平属性：margin-left、border-left、padding-left、width、padding-right、border-right、margin-right，这7个属性的值加在一起是元素包含块的宽度</li>
            <li>使用auto：从某种程度上讲，可以使用auto弥补实际值与所需总和的差距</li>
            <li>不止一个auto：将两个外边距设置为相等的长度是将元素居中的一种正确方法。不同于text-align，把text-align属性的值设为center并不能将元素居中；
                设置元素大小的另一种方法是将某个外边距以及width设置为auto，设置为auto的外边距会减为0
            </li>
            <li>负外边距：外边距可以为负</li>
            <li>百分数：如果width、内边距和外边距设置为百分数，会应用同样的基本规则；边框的宽度不能是百分数</li>
            <li>替换元素：非替换元素的所有规则同样适用于替换元素。例外，如果width为auto，元素的宽度则是内容的固有宽度；如果一个元素的width不同于其固有宽度，那么height值也会成比例变化</li>
            <li>垂直格式化：一个元素的默认高度由其内容决定，高度还会受内容宽度的影响，段落越窄，相应地就会越高；假设指定高度大于显示内容所需高度；假设高度小于显示内容所需的高度：浏览器会提供某种方法来查看所有内容，而不是增加元素框的高度，比如可能会向元素增加一个滚动条。如果元素内容的高度大于元素框的高度，用户代理的具体行为将取决于overflow属性</li>
            <li>垂直属性：margin-top、border-top、padding-top、height、padding-bottom、border-bottom、margin-bottom，这7个属性的值必须等于元素包含块的height。这7个属性中只有3个属性可以设置为auto：元素内容的height以及上、下外边距，上、下内边距和边框必须设置为特定的值，或者默认为0。</li>
            <li>百分数高度：没有显示声明包含块的height，百分数高度会重置为auto <code><div style="height: auto; "> <p style="height: 50%; ">Not half as tall; height reset to auto</p></div></code>使div的height为auto，段落将与div本身的高度完全相同</li>
            <li>auto高度：块级元素设置高度为auto时，将正好包括内联内容的高度。</li>
            <li>合并垂直外边距：垂直格式化的另一个重要方面是垂直相邻外边距的合并。这种合并行为只应用于外边距，如果元素有内边距和边框，它们绝对不会合并</li>
            <li>负外边距：负外边距会影响外边距如何合并。如果垂直外边距都设置为负值，浏览器会取两个外边距绝对值的最大值；如果一个正外边距与一个负外边距合并，会从正外边距减去这个负外边距的绝对值</li>
            <li>列表项：列表项有自身的一些规则。</li>
          </ol>
        </div>
        <div class="section">
          <h4>行内元素</h4>
          <ol>
            <li>行内元素：</br>
                行布局：内联内容如何布局
            </li>
            <li>基本术语和概念：</br>
                匿名文本（anonymous text）是指所有未包含在行内元素中的字符串</br>
                em 框：也称为字符框（character box）在字体中定义</br>
                内容区：内容区可以是元素中各字符的em框串在一起构成的框，也可以是由元素中字符字形描述的框。在替换元素中，内容区就是元素的固有高度再加上可能有的外边距、边框或内边距</br>
                行间距（leading）：是font-size值和line-height值之差，分为顶部和底部两部分（半间距）行间距只应用于非替换元素。</br>
                行内框：这个框通过向内容区增加行间距来描述。对于非替换元素，元素行内框的高度刚好等于line-height的值。</br>
                行框：这是包含该行中出现的行内框的最高点和最低点的最小框
            </li>
            <li>行内格式化：</br>
                如何确定一行的高度：行的高度由其组成元素和其他内容的高度确定
            </li>
            <li>行内非替换元素：</br>
                如果行中只包含非替换元素（或匿名文本）将如何构造：建立框，对于行内非替换元素或匿名文本某一部分，font-size值确定了内容区的高度。内容区加上行间距就等于行内框。行框定义为行中最高行内框顶端到最低行内框底端之间的距离，而且各行框的顶端挨着上一行行框的顶端。</br>
            </li>
            <li>垂直对齐：高度确定原则</br>
                属性 vertical-align；
                值 top将元素行内框的顶端与包含该元素的行框的顶端对齐；</br>
                bottom 将元素行内框的底端与包含该元素的行框的底端对齐；</br>
                text-top 将元素行内框的顶端与父元素内容区的顶端对齐；</br>
                text-bottom 将元素行内框的底端与父元素内容区的底端对齐；</br>
                middle 将元素行内框的垂直中点与父元素基线上0.5ex处的一点对齐；</br>
                super 将元素的内容区和行内框上移。上移的距离未指定，可能因用户代理的不同而不同。</br>
                sub 与super相同，只不过元素会下移而不是上移。</br>
                percentage 将元素上移或下移一定距离，这个距离由相对于元素line-height值指定的一个百分数确定
            </li>
            <li>管理line-height：改变一个行内元素的line-height可能导致文本行相互重叠。</br>
              如何避免内容重叠：对font-size有改变的元素结合使用em单位。line-height相对于元素本身的font-size设置，而不是相对于父元素设置。二是增加段落的line-height，会影响整个元素中的每一行，而不只是出现加边框超链接的那一行。
            </li>
            <li>缩放行高：设置line-height最好的办法是使用一个原始数字，作为一个缩放因子，而该因子是一个继承值而非计算值。还有一种最简单的方法，即适当设置样式，使行高恰好能包含行内容，设置line-height值1.0，使每个元素行内款与内容区相同</li>
            <li>增加框属性：行内元素的边框边界由font-size而不是line-height控制，不受内边距、外边距和边框的影响。</li>
            <li>行内替换元素：一般认为行内替换元素有固有的高度和宽度，换句话说，会用替换元素整体（包括内容、外边距、边距和内边距）来定义元素的行内框。替换元素可以增加行框的高度，但不影响line-height的值。然而，行内替换元素需要一个line-height值，在垂直对齐时才能正确地定位元素。</li>
            <li>增加框属性：行内替换元素应用内边距和边框会影响行框高度，它们会作为行内替换元素行内框的一部分。设置负外边距会使行内框小于正常大小，挤入其它行。</li>
            <li>替换元素和基线：默认行内替换元素位于基线上，如果向替换元素增加下内边距、外边距或边框，内容区会上移。</li>

          </ol>
        </div>
        <div class="section">
          <h4>改变元素显示</h4>
          <ol>
            <li>改变元素显示：属性 display； 值 none | inline | block | inline-block | list-item | run-in | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row |table-column-group | table-column | table-cell | table-caption | inherit</li>
            <li>改变角色：想设置一个文档的样式，可以通过改变元素的显示角色来实现。假设一个div中有一系列链接，想把div布局为一个垂直边栏。一可以把所有链接都放在表单元格中；二可以把每个链接都包在自己的div中；三可以把它们设置为块级元素 <code>div#navigation a { display:block; }</code>记住，改变的只是元素的显示角色，而不是其本质</li>
            <li>行内块元素（inline-block element）块级元素和行内元素的混合。行内块元素会作为替换元素放在行中，底端默认位于文本行的基线上，而且内部没有分隔符。其实就是把块级元素放在行中。行内块元素自动调整大小，例如，设计5个超链接在一个工具条中宽度相等 <code>#navbar a { display:inline-block; width:20%; }</code></li>
            <li>run-in元素：块/行内元素混合。如果一个元素生成一个run-in框，而且该框后面是一个块级框，那么该run-in元素将成为块级框开始处的一个行内框。如果run-in框后不跟块级框，run-in框本身将成为块级框。</li>
            <li>计算值：如果元素是浮动元素或定位元素，display的计算值可以改变；如果一个元素是绝对定位，float的值设置为none。</li>
          </ol>
        </div>
      </div>
      <div class="content">
        <h3>内边距、边框和外边距</h3>
        <div class="section">
          <h4>基本元素框</h4>
          <ol>
            <li>所有文档元素都生成一个矩形框，成为元素框（element box）描述了一个元素在文档布局中所占的空间大小。每个框影响着其它元素框的位置和大小。</li>
            <li>宽度和高度：一个元素的width被定义为从左内边界到右内边界的距离，height被定义为从上内边界到下内边界的距离。两个属性不能应用到行内非替换元素。</li>
            <li>外边框和内边距：有三种方法在元素外围生成额外的空间。一增加内边距；二增加外边距；三同时增加内边距和外边距。</li>
          </ol>
        </div>
        <div class="section">
          <h4>外边距</h4>
          <ol>
            <li>margin可以接受任何长度度量，可以是像素、英寸、毫米或em，默认值为0。</li>
            <li>长度值和外边距：设置元素的外边距时，可以使用任何长度值。<code>p { background:silver; margin: 10px; }</code> margin: top right bottom left</li>
            <li>百分数和外边距：可以对元素的外边距设置百分数值，百分数是相对于父元素的width值计算的。</li>
            <li>值复制：CSS制定了一些规则，允许为外边距指定少于4个值。上下左右指定两个值是上下一个值，左右一个值；如果缺少右外边距的值，则使用上外边距的值。</li>
            <li>单边外边距属性：margin-top、margin-right、margin-bottom、margin-left</li>
            <li>负外边距和合并外边距：可以为元素设置负外边距。会导致元素框超出其父元素，或者与其它元素重叠，但并不违反框模型。</li>
            <li>外边距和行内元素：行内非替换元素应用上下外边距，对行高没有任何影响；左右外边距正常显示；应用负外边距，不会影响元素的上下外边距跟行高，但会使左右两端与其它内容重叠</li>
          </ol>              
        </div>
        <div class="section">
          <h4>边框（border）</h4>
          <ol>
            <li>元素的边框就是围绕元素内容和内边距的一条或多条线。边框默认有3个方面：宽度、样式、颜色。默认的边框颜色是元素本身的前景色；如果没有为边框声明颜色，它将与元素的文本颜色相同。</li>
            <li>边框和背景：边框绘制在元素的背景之上。有样式的边框，属性 border-style；值 none | hidden | dotted | dashed | solid | double | groove |ridge | inset | outset | inherit</li>
            <li>多种样式：顺序 top-right-bottom-left | top-right/left-bottom | top/bottom-right/left</li>
            <li>单边样式：属性 border-top-style | border-right-style | border-bottom-style | border-left-style</li>
            <li>边框宽度：属性 border-width； 值 thin | medium | thick | length | inherit </li>
            <li>单边属性：border-top-width | border-right-width | border-bottom-width | border-left-width</li>
            <li>如果没有声明样式，就相当于声明border-style: none
            边框颜色：属性 border-color；值 color | transparent | inherit 如果没有声明颜色，默认颜色则是元素的前景色。单边属性：border-top-color | border-right-color | border-bottom-color | border-left-color</li>
            <li>透明边框：值transparent用于创建有宽度的不可见边框
            </li>
          </ol>         
        </div>
        <div class="section">
          <h4>内边距</h4>
          <ol>
            <li>元素框的内边距在边框和内容之间。属性 padding；值 length | percentage | inherit 默认地，元素没有内边距，元素的边框与元素本身的内容相当接近。设置段落时，外边距会合并，内边距不合并。<code>p { margin: 0; padding: 0.5em, 0; }</code></li>
            <li>百分数值和内边距：可以为元素的内边距设置百分数，百分数值要相对于其父元素的width计算。上下内边距与左右内边距一致，上下内边距的百分数也是相对于父元素宽度计算而不是相对于高度。</li>
            <li>单边内边距：padding-top | padding-right | padding-bottom | padding-left</li>
            <li>内边距和行内元素：理论上，对于有背景色和内边距的行内非替换元素，背景可以向元素上面和下面延伸，不改变行高。</li>
            <li>内边距和替换元素：可以向替换元素应用内边距。不论替换元素是块级元素还是行内元素，内边距都会围绕其内容，将背景色填入该内边距。</li>
          </ol>
        </div>
      <div class="content">
        <h3>颜色和背景</h3>
        <div class="section">
          <h4>颜色</h4>
          <ol>
            <li>使用样式前最好做些规则。例如，只想改变导航栏中超链接的颜色<code>#navbar a { color: yellow; }</code></li>
          </ol>
        </div>
        <div class="section">
          <h4>前景色</h4>
          <ol>
            <li>在CSS中，可以为任何元素设置前景和背景色，前景是元素的文本，也包括元素周围的边框。属性 color 设置突出文本，让用户注意。</li>
            <li>替换属性： 利用锚元素，替换HTML中的Body属性</li>
            <li>影响边框：边框颜色会取自内容颜色，要覆盖边框颜色，最基本的方法是使用属性border-color</li>
            <li>影响表单元素：为表单元素设置color值，改变表单元素前景色。</li>
            <li>继承颜色：color属性是可以继承的。</li>
          </ol>
        </div>
        <div class="section">
          <h4>背景</h4>
          <ol>
            <li>背景色：元素的背景区包括前景之下直到边框外边界的所有空间，因此，内容框和内边距都是元素背景的一部分，且边框画在背景之上。属性 bacoground-color；值 color | transparent | inherit 可以为几乎所有元素设置背景色，默认为透明。</li>
            <li>背景图像：属性 background-image；值 url | none | inherit 使用背景图像，需要指定url <code>body { background-image: url(bg1.jpg) }</code> 允许向任何元素应用背景图像，可以是块级元素也可以是行内元素。</li>
            <li>背景图像的良好实践：只要有背景图像就应该同时包含一个背景颜色。</li>
            <li>有方向的重复： 属性 background-repeat；值 repeat | repeat-x | repeat-y | no-repeat | inherit 可以设置图像沿x轴水平平铺，也可以沿y轴垂直平铺，也可以不重复图像。</li>
            <li>背景定位：如何改变图像在背景中的位置。属性 background-position；值 percentage | length | left | center | right | top | bottom | inherit 应用于块级元素和替换元素。</br>图像放置利用关键字实现，位置关键字可以按任何顺序出现，只要保证不能超过两个关键字-一个对应水平方向，一个对应垂直方向。</br>百分数值：百分数值同时应用于元素和原图像。等价的位置关键字和百分数值。<br>长度值：在为原图像提供长度值时，这些长度值将解释为从元素内边距左上角的偏移，偏移点是原图像的左上角。如果使用长度值或百分数值，可以使用负值将原图像拉出元素的背景区。可以使用background-position属性设置平铺模式的起点。</li>
            <li>关联：属性 background-attachment；值 scroll | fixed | inherit 防止用户滚动文档时图像消失，可以声明原图像是相对于可视区固定。例如设置background-attachment的值为fixed，可以使原图像不会随文档位置滚动，且原图像的放置由可视区的大小确定，而不是由包含该图像的元素的大小。</li>
            <li>汇总：属性 background； 值 background-color | background-image | background-repeat | background-attachment | background-position 对background-position属性值有必须按水平值在前垂直值在后的顺序。background是一个简写属性，为指定属性值时会默认为none，其默认值会覆盖先前为给定元素指定的值。例如，设置除背景色不同的h1,h2 <code>h1,h2 { background: silver url(trees.ipg) center repeat-x; } h2 { background-color: silver; } 只会改变背景色，而不会覆盖所有其他值。 </code></li>
          </ol>
        </div>
      </div>
      <div class="content">
        <h3>浮动和定位</h3>
        <div class="section">
          <h4>浮动</h4>
          <ol>
            <li>浮动属性 float 允许浮动任何元素，值 left | right | none | inherit 一个元素浮动时，其它内容会环绕该元素；浮动元素周围的外边距不会合并；不浮动属性 float: none用于防止元素浮动。</li>
            <li>浮动的详细内幕：建立浮动元素的包含块（containing block）是其最近的块级祖先元素。浮动元素有一些特定规则。
            </li>
            <li>清除：属性 clear；值 left | right | both | none | inherit 应用于块级元素。例如，确保一个h3左边没有浮动图像 <code> h3 { clear:left; }</code></li>
          </ol>
        </div>
        <div class="section">
          <h4>定位</h4>
          <ol>
            <li>定位的原理：定义元素框相对于父元素或者其正常位置的定位。</li>
            <li>定位的类型，属性 position； 值 static | relative | absolute |fixed | inherit 应用于所有元素。不同类型的定位，会影响元素框的生成方式。<br>static 元素框正常生成，块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。<br>relative 元素框偏移某个距离 <br> absolute 元素框从文档流完全删除，并相对于其包含块定位 <br> fixed 元素框的表现将类似于将position设置为absolute，不过其包含块是视窗本身。<br>
            </li>
            <li>包含块：根元素：初始包含块由用户代理建立，是一个视窗大小的矩形；非根元素，按position值的不同，包含块的构成也不同：</li>
            <li>偏移属性（offset properties） top | right | bottom | left 值 length | percentage | auto | inherit 应用于定位元素，正值会导致向内偏移，使边界朝着包含块的中心移动，而负值会导致向外偏移。</li>
            <li>宽度和高度：为特定元素指定宽度和高度。可以使用偏移属性定位元素的同时设置元素大小。 倘若向元素增加了外边距、边框或内边距，定位元素会超过包含块。要想保证元素不超出其包含块，可以去除height和width声明，或者显式地将其设置为auto。</li>
            <li>限制宽度和高度：最大最小属性（min-max properties）通过使用min-width、min-height和max-width、max-height可以为元素的内容区定义一个最小尺寸。应用于除非替换行内元素和表元素以外的所有元素。值不能为负。最小最大属性的一个好处是可以相对安全地混合使用不同的单位。</li>
            <li>内容溢出和剪裁：如果一个元素的内容对于元素大小来说过大，就有可能溢出元素本身。可以使用overflow属性处理。值 visible | hidden | scroll | auto | inherit 应用于块级元素和替换元素。visible值允许元素的内容在元素框外可见；scroll允许内容下拉显示；hidden值会使元素的内容在元素框的边界处剪裁；auto值允许用户代理来确定采用何种行为。</li>
            <li>内容裁剪：属性clip可以改变剪裁区域的形状。默认值auto表示元素的内容不应剪裁。值 rect(top, right, bottom, left) | auto | inherit 应用于绝对定位元素</li>
            <li>元素可见性：属性 visibility；值 visible | hidden | collapse | inherit 应用于所有元素，可继承。不同于display:none删除元素，visiblity: hidden只是使元素不可见，但不删除其元素框</li>
            <li>绝对定位：元素绝对定位时，会从文档流中完全删除。绝对定位元素可能覆盖其他元素，或者被其他元素覆盖。绝对定位元素的包含块是最近的position值不为static的祖先元素，通常将position值指定为relative。强调一点，元素绝对定位时，会为其后代元素建立一个包含块。</li>
            <li>绝对定位元素的放置和大小：元素框的高度和宽度由其外边距边界的放置决定，如果不显式设置包含块的宽度和高度</li>
            <li>自动边偏移：元素绝对定位时，如果除bottom外某个任意偏移属性设置为auto，会有一种特殊的行为。</li>
            <li>非替换元素的放置和大小：一般地，元素的大小和位置取决于其包含块。设置左右外边距为相等的值（或auto）会让绝对定位元素水平居中</li>
            <li>替换元素的放置和大小：非替换元素和替换元素的定位规则大不相同。</br>
            如果width设置为auto，width的实际使用值由元素内容的固有宽度决定。</br>
            在从左向右读的语言中，如果left值为auto，要把auto替换为静态位置。在从右向左读的语言中，则把right的auto值替换为静态位置。</br>
            如果left或right仍为auto，则将margin-left或margin-right的auto值替换为0。</br>
            如果此时margin-left和margin-right都还定义为auto，则把它们设置为相等的值，从而将元素在其包含块中居中。</br>
            在此之后，如果只剩下一个auto值，则将其修改为等于等式的余下部分。</br>
            与非替换元素绝对定位时的基本行为相同。
            </li>
            <li>沿垂直轴的布局规则： <br>
                如果height设置为auto，height的计算值由元素内容的固有高度确定。<br>
                如果top的值为auto，将其替换为替换元素的静态位置<br>
                如果bottom的值为auto，将margin-top或margin-bottom的所有auto值替换为0。<br>
                如果此时margin-top和margin-bottom都还定义为auto，将其设置为相等的值，从而使元素在其包含块中居中。<br>
                在此之后，如果仅剩下一个auto值，则将其修改为等于等式中的余下部分<br>
                与非替换元素一样，如果值过度受限，用户代理会忽略bottom。
            </li>
            <li>Z轴上的放置：属性 z-index；值 integer | auto | inherit 应用于定位元素。利用z-index可以改变元素相互覆盖的顺序。<br> z轴为从前向后，越来越远离用户。在这个坐标系中，由较高z-index值的元素比z-index值较低的元素离读者更近。<br> 所有整数都可以用作z-index的值，包括负数。<br> 一旦为一个元素指定了z-index值，该元素就会建立自己的局部叠放上下文。元素相对于其父元素准确定位，而不是相对于总的文档。<br> 默认值为auto，不会建立新的局部叠放上下文。
            </li>
            <li>固定定位：</li>
          </ol>
        </div>
      </div>
      </div>
    </div>
  </div>
  <div class="footer"></div>
</body>
</html>
